from typing import Iterator

def lcg(seed: int, m: int=2**32, a: int=1664525, c: int=1013904223) -> Iterator[int]:
    """
    This generator implements the Linear Congruential Generator algorithm
    :param m: the modulus, a positive integer constant
    :param a: the multiplier, a non-negative integer constant < m
    :param c: the increment, a non-negative integer constant < m
    :param seed: the starting state of the LCG. It is used to initialize the pseudo-random number sequence
    :return: a non-negative integer in [0, m-1] representing the i-th state of the generator
    """
    x = seed
    while True:
        x = (a * x + c) % m
        yield x/m

def xorshift_64(seed: int) -> Iterator[int]:
    """
    This generator implements the XORShift algorithm.
    :param seed: the initial state of the generator. Should be a non-zero integer.
    :return: pseudo-random integers generated by the XORShift algorithm.
    """
    x = seed if seed != 0 else 1
    while True:
        x ^= (x << 13) & 0xFFFFFFFFFFFFFFFF
        x ^= (x >> 7) & 0xFFFFFFFFFFFFFFFF
        x ^= (x << 17) & 0xFFFFFFFFFFFFFFFF
        x &= 0xFFFFFFFFFFFFFFFF
        yield x/0xFFFFFFFFFFFFFFFF


def rotl(x: int, k: int) -> int:
    return ((x << k) | (x >> (64 - k))) & 0xFFFFFFFFFFFFFFFF

def xoshiro_64(seed: list[int]) -> Iterator[int]:
    """
    xoshiro256++ generator
    :param seed: list of 4 uint64 integers, the internal state (cant be all 0)
    :return: pseudo-random 64-bit integers
    """
    s = seed.copy()
    if len(s) != 4 or all(x == 0 for x in s):
        raise ValueError("Seed must be a list of 4 non-zero uint64 integers")

    while True:
        result = (rotl(s[0] + s[3], 23) + s[0]) & 0xFFFFFFFFFFFFFFFF
        t = (s[1] << 17) & 0xFFFFFFFFFFFFFFFF

        s[2] ^= s[0]
        s[3] ^= s[1]
        s[1] ^= s[2]
        s[0] ^= s[3]

        s[2] ^= t
        s[3] = rotl(s[3], 45)

        yield result/0xFFFFFFFFFFFFFFFF
